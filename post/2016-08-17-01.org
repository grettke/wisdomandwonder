#+DATE: [2016-08-17 Wed 20:15]
#+OPTIONS: toc:nil num:nil todo:nil pri:nil tags:nil ^:nil
#+CATEGORY: Article
#+TAGS: Babel, Emacs, Ide, Lisp, Literate Programming, Programming Language, Reproducible research, elisp, org-mode
#+TITLE: Why To Use Org-Mode's ID, CUSTOM_ID, and NAME

The following are my notes about why and how I started using =ID,= =CUSTOM_ID=, and
=NAME= with [[https://github.com/grettke/help][HELP]] in chronological order.

They are accurate where they can be and recollections where they can't.

Originally I wanted to publish this as separate posts, but it doesn't make
sense to me separately, so here goes.

Please notify me of errors, issues, and improvements where you can!

#+HTML: <!--more-->

* Automatically Perform Actions Upon Specific Headlines

When I set up [[https://github.com/grettke/home/blob/master/TC3F.org][TC3F]], I manually exported it to =ASCII= in case anyone wanted to
read it. Same goes for [[https://github.com/grettke/home/blob/master/ALEC.org][ALEC]]. Although I figured that virtually no one read
either of the weaved documents, it seemed like a wasted opportunity not trying
out all of them so I kept it in the back of my mind wondering where might be a
good opportunity. When I refactored =ALEC= into [[https://github.com/grettke/help][HELP]] that opportunity came;
suddenly in addition to the document itself I also had two more documents that
I cared about *a lot*: the [[https://github.com/grettke/help/blob/master/README.md][README]] and the [[https://github.com/grettke/help/blob/master/STYLEGUIDE.md][STYLEGUIDE]].

The =README= contains the minimal steps to get =HELP= up and running. When I set
up a new box, /I/ use it. Even when I automate most of the process, I /refer/ to
it; otherwise I just wouldn't remember.

The =STYLEGUIDE= contains every decision I consciously made about writing this
document. It ain't rocket science, but it is mine and I can't remember all of
it so I wrote it down. One of the most frequently used reminders that I keep
coming back to in there is how choose between formatting =code= and =verbatim=...
that one /still/ needs refinement because I break that rule all the time lol.
Even as I write this document, I'm glad to see that I at least /noted/ that it is
important to always set a unique =ID= for every =Headline= (more later).

That makes *six weavings (exports)*, way too many to do manually because it is
tedious and time consuming. Really, it is. The folks on the Org-Mode mailing
list (link excluded because all of my links are to gmame which no longer
exists) showed me how to go somewhere and do something so I pieced together
the following to automate all of the weaving of =HELP=:

#+NAME: 7F835528-B720-430E-8B14-190A4BA9FD0B
#+BEGIN_SRC emacs-lisp
(defun help/org-weave-subtree-gfm (id file)
  "Export the subtree with ID to FILE in gfm."
  (interactive)
  (help/save-all-file-buffers)
  (save-excursion
    (let ((hidx (org-find-property "ID" id)))
      (when hidx
        (goto-char hidx)
        (org-export-to-file 'gfm file nil t nil)))))

(defun help/org-weave-readme ()
  (interactive)
  (help/org-weave-subtree-gfm
   "README"
   "README.md"))

(defun help/org-weave-style-guide ()
  (interactive)
  (help/org-weave-subtree-gfm
   "STYLEGUIDE"
   "STYLEGUIDE.md"))

(defun help/weave-everything-everywhere ()
  "Export this entire document in configured weavers."
  (interactive)
  (save-excursion
    (org-ascii-export-to-ascii)
    (org-html-export-to-html)
    (org-gfm-export-to-markdown)
    (org-latex-export-to-pdf))
  (help/org-weave-readme)
  (help/org-weave-style-guide))
#+END_SRC

Every few days/weeks/months/years I call =help/weave-everything-everywhere=, go
for a walk, and publish new versions of the documents. It has worked great for
a long time. Going to a Headline with a specific =ID= is my introduction to =ID=
and it has worked great.

#  LocalWords:  Ide elisp README STYLEGUIDE lol weavings gmame

* Easily Share Tangled And Weaved Documents With Non Org-Mode Users

One of the *big scary stories* told about Org-Mode is that it is virtually
impossible to utilize tangled-documents on mixed-teams of Org-Mode-Users and
Non-Org-Mode-Users. Like most stories, when you shine some light on them the
fear disappears instantly. That got me curious about something easier than
doing mixed-development: just sharing. How do you share tangled and weaved
documents in a pleasant way with Non-Org-Mode users (or any users for that
matter actually)? The scary user story here goes something like this:

- David wrote a document in Org-Mode
- He tangled it to an Emacs-Lisp program
- Jennifer read the program and wants to know why it works the way it does,
  one specific line actually
  #+BEGIN_EXAMPLE
;; [[file:Org-Mode_Fundamentals.org::AD42B561-29FA-4652-AD28-692CAD631E62][AD42B561-29FA-4652-AD28-692CAD631E62]]
(help/set-org-babel-default-header-args :comments "noweb")
;; AD42B561-29FA-4652-AD28-692CAD631E62 ends here
  #+END_EXAMPLE
- Jennifer realizes that the program has actually been tangled then so
  obviously: Human sacrifice, dogs and cats living together... mass hysteria!

Hold on. It ain't that bad. It isn't even scary. Here is what really will
happen:

- David wrote a document in Org-Mode
- He tangled it to an Emacs-Lisp program
- Jennifer read the program and wants to know why it works the way it does,
  one specific line actually
  #+BEGIN_EXAMPLE
;; [[file:Org-Mode_Fundamentals.org::AD42B561-29FA-4652-AD28-692CAD631E62][AD42B561-29FA-4652-AD28-692CAD631E62]]
(help/set-org-babel-default-header-args :comments "noweb")
;; AD42B561-29FA-4652-AD28-692CAD631E62 ends here
  #+END_EXAMPLE
- Jennifer realizes that the program has actually been tangled so she pieces
  together what the tangled document is telling her, namely that
  - The source code she is looking at
    - Came from the physical file [[https://github.com/grettke/help/blob/master/.org-mode-fundamentals.emacs.el#L120][Org-Mode_Fundamentals.org]]
      - Holding the =NAME= =AD42B561-29FA-4652-AD28-692CAD631E62=
- To study where the source code came from she simply opens up that Org-Mode
  file and searches for that name. Doesn't this betray the whole point of
  Literate Programming's =tangle= and =weave= business? Why should she look at the
  source code why isn't reading a human-readable document? Excellent point.
- To study the human-readable document for where the source code came from and
  why, she opens up the [[https://github.com/grettke/help/blob/master/Org-Mode_Fundamentals.md][Markdown file]] and searches for
  =49787FC5-CAA7-466B-B742-0F38973E070B= and finds an explanation of what this
  code does. In practice she would probably just read the source code inside
  of Emacs once she switches to Emacs, but /this/ gives her a means of
  leveraging LP before making the switch.

My goal is that *anyone* can make sense of LP documents, *any* of them. It turns
out that it is pretty simple to do so, it just takes a few different settings
to make that happen:

- Configure [[http://orgmode.org/manual/comments.html][:comments]] as =noweb=
- Configure your weaver to include the =ID=
  - Help the reader make sense of the document by displaying it's internal
    properties.
  #+NAME: EB94858A-C299-4F0E-91CA-39ADD9AA73C8
  #+BEGIN_SRC emacs-lisp
(setq org-export-with-properties t)
  #+END_SRC
- Easily jump from comments to the origin source block by opening the tangled
  file in Emacs and changing the mode to =org-mode= and clicking on the link
  - Jennifer searched manually which works really well, too

When you de-mystify Org-Modes literate tangling and weaving you find that it
is /just a plain old program/ like everything else and all of the fear about it
is plain old =FUD=.
* Automatically Allocate ID and NAME

Org-Mode documents are hierarchical data structures. Each node is a =Headline=.
Humans distinguish them by the text of the headline. For example the text of
*this* headline is (as of writing) =Automatically Allocate ID and NAME=. That can
change over time. In fact it is likely to change. If you have references to a
headline by name, you will break them when you change the name. Ouch, no way,
that is needless pain. It is easier to give a unique =ID= to every single
=Headline=. Most of the time I don't even care about the =ID=; only using it twice
ever. The rest of the time it just needs to be unique. Here is the code that I
put together to make sure that every =Headline= has a unique =ID=:

#+NAME: 4B5F24EF-3E74-4CF2-A207-0301515B4E71
#+BEGIN_SRC emacs-lisp
(defun help/org-prp-hdln ()
  "Visit every Headline. If it doesn't have an ID property then add one and
  assign it a UUID. Attribution: URL `http://article.gmane.org/gmane.emacs.orgmode/99738'"
  (interactive)
  (save-excursion
    (goto-char (point-min))
    (dolist (p (nreverse
                (org-element-map (org-element-parse-buffer 'headline) 'headline
                  (lambda (headline) (org-element-property :begin headline)))))
      (goto-char p)
      (org-id-get-create))
    (save-buffer)))
#+END_SRC

This way you can refactor your =Headlines= as much as you want without your code
breaking. This is probably a pretty [[https://stackoverflow.com/questions/13340616/assign-ids-to-every-entry-in-org-mode][common task]].

Org-Babel's helper functions make it trivially easy to perform Lisp style
iterative development inside of Emacs-Lisp while working inside of an Org-Mode
document. It is awesome and addictive. A natural outcome here is that you can
and will break up large chunks of code into individual source blocks. You
won't want to name all of them because they aren't all that special. Typically
you onlye name allocate =noweb-ref= names when you want to call those source
blocks. The rest of the time you just need to make sure that they have a name,
any name, so that they are traceable from tangled code back to the source
document. To make sure of that, I when I tangle a document I run code to make
sure that every =Source Block= has a unique name:

#+NAME: A23CCE01-3592-495F-99E4-A18FF600F674
#+BEGIN_SRC
(defun help/org-prp-src-blk ()
  "If it doesn't have a NAME property then add one and
   assign it a UUID. Attribution: URL `http://article.gmane.org/gmane.emacs.orgmode/99740'"
  (interactive)
  (help/org-2every-src-block
   #'(lambda (element)
       (if (not (org-element-property :name element))
           (let ((i (org-get-indentation)))
             (beginning-of-line)
             (save-excursion (insert "#+NAME: " (org-id-new) "\n"))
             (indent-to i)
             (forward-line 2))))))

(defconst help/org-special-pre "^\s*#[+]")

(defun help/org-2every-src-block (fn)
  "Visit every Source-Block and evaluate `FN'."
  (interactive)
  (save-excursion
    (goto-char (point-min))
    (let ((case-fold-search t))
      (while (re-search-forward (concat help/org-special-pre "BEGIN_SRC") nil t)
        (let ((element (org-element-at-point)))
          (when (eq (org-element-type element) 'src-block)
            (funcall fn element)))))
    (save-buffer)))
#+END_SRC

The net result here is that you get 100% traceability with virtually no effort.

* Easily Configure Source Blocks

After refactoring huge chunks of code into documented source blocks by hand it
got old, fast. In an attempt to automate it I set up a [[https://github.com/joaotavora/yasnippet][YASnippet]] to automate
as much as possible including giving it a unique =NAME=:

#+BEGIN_EXAMPLE
# -*- mode: snippet -*-
# key: sc
# name: Source Block
# group: HELP
# contributor: gcr@wisdomandwonder.com
# expand-env: ((yas-indent-line 'fixed))
# --
,#+NAME: ${1:`(org-id-new)`}
,#+BEGIN_SRC ${2:$$(let ((langs (sort (-map (lambda (x) (symbol-name (car x))) org-babel-load-languages) 'string<))) (yas-choose-value (if (-contains? langs "shell") (-snoc langs "sh") langs)))}${2:$(when (-contains? '("ditaa" "dot" "plantuml") yas-text) (concat " :file \\"./image/" (yas-field-value 1) ".png\\""))} $3
$0
,#+END_SRC
#+END_EXAMPLE

* Outcomes Of This Approach

The long and the short of is that this worked out really well for me. It has
taken a while to try it out and perfect, and I really like it because it is so
simple: I'm only using what Org-Mode provides out of the box. All it took as
reading the manual, asking questions, getting help, and trying stuff out. The
hardest part was figuring out what I wanted to do.

** Easy Attribution and Researching

Most of the Emacs configuration universe consists of snippets that have been
passed around via the SneakerNet, EmacsWikiNet, and InterNet. That rocks. If
you read my [[https://github.com/grettke/help/blob/master/.emacs.el][.emacs.el]] you will find =Attribution= lines all over the place. I am
not unique here. What I am curious about is how to easily attribute code
across publishing mediums. My config here makes it easy because every single
code snippet has a =UUID= associated with it. Not perfect, but it is a start
because you can use the same =UUID= across source code and human-readable
documents. That is very exciting and is not about enforcing ownership and
totally about making it easy to track down who did what and why just to know,
which is always a big topic for Emacs-Lisp code.

** Easy Iterative Development

[[http://orgmode.org/manual/noweb_002dref.html][noweb-ref]] makes it easy to use a natural iterative coding style in your
Org-Mode document iself. Automatic naming of Headlines and Source Blocks makes
it easy to keep track of what came from where and why.

** Easy Sharing

Easily study all kinds of documents inside Emacs, or out.

* Making Sense Of CUSTOM_ID

Today I was reviewing my TODO list and found this entry "Replace ID with
CUSTOM_ID because of [[https://github.com/jgm/pandoc/releases/tag/1.17.1][this]]". That links explains that

#+BEGIN_EXAMPLE
Use CUSTOM_ID in properties (Albert Krewinkel). The ID property is reserved
for internal use by Org-mode and should not be used. The CUSTOM_ID property is
to be used instead, it is converted to the ID property for certain export
format.
#+END_EXAMPLE

** Researching Why

Oh, OK. Why?

Here is what [[http://orgmode.org/cgit.cgi/org-mode.git/plain/etc/ORG-NEWS][ORG-NEWS]] said about "CUSTOM_ID": nothing.

[[http://news.gmane.org/gmane.emacs.orgmode][GMAME]] is gone so there is nothing to see there.

[[https://lists.gnu.org/archive/cgi-bin/namazu.cgi?query=CUSTOM_ID&submit=Search%2521&idxname=emacs-orgmode&max=20&result=normal&sort=score][This search]] turns up nothing.

Then I started searching the web and learned the following:

- [[http://orgmode.org/manual/Internal-links.html][Internal Links]]
  #+BEGIN_EXAMPLE
If the link does not look like a URL, it is considered to be internal in the
current file. The most important case is a link like ‘[[#my-custom-id]]’ which
will link to the entry with the CUSTOM_ID property ‘my-custom-id’. You are
responsible yourself to make sure these custom IDs are unique in a file.
  #+END_EXAMPLE
- [[http://orgmode.org/manual/Handling-links.html][Handling links]]
  #+BEGIN_EXAMPLE
C-c l     (org-store-link)

Store a link to the current location. This is a global command (you must
create the key binding yourself) which can be used in any buffer to create a
link. The link will be stored for later insertion into an Org buffer (see
below). What kind of link will be created depends on the current buffer:  Org
mode buffers For Org files, if there is a ‘<<target>>’ at the cursor, the link
points to the target. Otherwise it points to the current headline, which will
also be the description1.

If the headline has a CUSTOM_ID property, a link to this custom ID will be
stored. In addition or alternatively (depending on the value of
org-id-link-to-org-use-id), a globally unique ID property will be created
and/or used to construct a link2. So using this command in Org buffers will
potentially create two links: a human-readable from the custom ID, and one
that is globally unique and works even if the entry is moved from file to
file. Later, when inserting the link, you need to decide which one to use.
  #+END_EXAMPLE
- 
